/*
  This is a textX specification of pyFlies DSL for cognitive test
  experiments definition.
  Author: Igor R. Dejanovic <igor DOT dejanovic AT gmail DOT com>
  Copyright: (c) 2014-2020 Igor R. Dejanovic <igor DOT dejanovic AT gmail DOT com>
  License: GPLv3 License
*/

PyFliesModel:
  (description=Description)?
  vars*=VariableAssignment
  blocks+=BlockType
  structure=Structure
  targets*=Target
;

Description: '"""'- /((?!""")(.|\n))*/ '"""'-;

BlockType:
  TestType | ScreenType
;

VariableAssignment:
    name=VariableName '=' value=Expression
;

Value:
    String | CompoundTypeValue | BaseValue
;

BaseValue: value=STRICTFLOAT | value=INT | value=BOOL;
String: value=STRING;
CompoundTypeValue: Range | List;
Range: lower=INT '..' upper=INT;
List: '[' values*=Expression[','] ']';
VariableRef: name=VariableName;
VariableName: ID;


/*
    Expressions
*/
Expression: IfExpression | LoopExpression | OrExpression;
IfExpression: if_true=OrExpression 'if' cond=OrExpression 'else' if_false=OrExpression;
OrExpression: op=AndExpression ('or' op=AndExpression)*;
AndExpression: op=NotExpression ('and' op=NotExpression)*;
NotExpression: (opn='not')? op=ComparisonExpression;
ComparisonExpression: op=AdditiveExpression ( opn=ComparisonOperator op=AdditiveExpression)*;
ComparisonOperator: '=='|'!='|'<='|'>='|'>'|'<';
AdditiveExpression: op=MultiplicativeExpression (opn=AdditiveOperator op=MultiplicativeExpression)*;
AdditiveOperator: '+'|'-';
MultiplicativeExpression: op=UnaryExpression (opn=MultiplicativeOperator op=UnaryExpression)*;
MultiplicativeOperator: '*'|'/';
UnaryExpression: (opn=SignOperator)? op=PrimaryExpression;
SignOperator: '-' | '+';
PrimaryExpression: '(' Expression ')' | MessageExpression | Value | VariableRef;
MessageExpression: value=CompoundTypeValue message=Message;
Message: 'choose' | 'shuffle';
LoopExpression: exp=OrExpression 'loop';


TimeReference: start_relative?='.' (relative_op=SignOperator)? time=AdditiveExpression;

/*
    Test specification
*/

TestType:
  "test" name=ID "{"
    'conditions' '{'
        table=ConditionsTable
    '}'

    'stimuli' '{'
        stimuli+=ConditionStimuli
    '}'
  "}"
;

ConditionsTable:
    // Condition table is given in orgmode table format. Various editor plugins
    // exists to support convenient editing of this table format.

    // Variable names are in the first line of condition specification
    '|' variables+=WORD['|'] '|'
    /\|(-*\+)+-*\|/

    // The rest of the description are condition specifications, one per line
    // The order of condition values match the param name positions.
    cond_specs+=Condition
;

Condition:
  '|' var_exps+=Expression['|'] '|'
;

ConditionStimuli:
  // Condition stimuli is given in the form of
  // condition match expression : stimuli definitions
  condition=Expression ':' stimuli+=StimulusSpec
;


/*
    Stimuli spec
*/

StimulusSpec:
    ('at' at=TimeReference)? (record?='record' | stimulus=Stimulus)
    ('for' duration=AdditiveExpression)?;

Stimulus: name=StimulusName '(' params*=StimulusParam[',']  ')';
StimulusParam: name=ID value=Expression;

StimulusName: 'cross' | 'circle' | 'rectangle' | 'line' | 'image' | 'sound' | 'audio';

/*
    Concrete stimuli with parameters and default values will be
    defined in model/obj. processors to produce better error report.

Image:
    'image' '('
    (
        ('file' file=STRING)
        ('position' x=WORD (y=INT)?)
        ('width' width=Expression)?
        ('height' height=Expression)?
    )#[',']
  ')'
;

Circle: 'circle' '('
    (
        ('position' x=Expression (y=Expression)?)
        ('radius' radius=Expression)
        ('color' color=WORD)?
        ('fillColor' fillColor=WORD)?
        ('lineWidth' lineWidth=WORD)?
    )#[',']
    ')'
;

Rectangle:
    'rectangle' '('
    (
        ('position' x=Expression (y=Expression)?)
        ('width' width=Expression)?
        ('height' height=Expression)?
        ('color' color=WORD)?
        ('fillColor' fillColor=WORD)?
        ('lineWidth' lineWidth=WORD)?
    )#[',']
    ')'
;

Line:
    'line''('
    (
        ('from' from=Point)
        ('to' to=Point)
        ('color' color=WORD)?
        ('fillColor' fillColor=WORD)?
        ('lineWidth' lineWidth=WORD)?
    )#[',']
    ')'
;

Cross:
    'cross' '('
    (
        ('position' x=Expression (y=Expression)?)
        ('width' width=Expression)?
        ('height' height=Expression)?
        ('color' color=WORD)?
        ('fillColor' fillColor=WORD)?
        ('lineWidth' lineWidth=WORD)?
    )#[',']
    ')'
;

Text:
  'text' '(' text=TextType
   (','
        ( ('position' x=WORD (y=INT)?)?
          ('size' size=INT)?
          ('color' color=WORD)?
        )#[','])?
  ')'
;

Sound:
  'sound' '(' frequency=INT
    (',' (
           ('duration' duration=Duration)?
           (target?='target')
         )#[',']
    )?
  ')'
;

Audio:
  'audio' '(' file=STRING
    (',' (
           ('duration' duration=Duration)?
           (target?='target')
         )#[',']
    )?
  ')'
;


TextType:
  STRING | /\w*\b/
;


Duration:
   // _from , to - duration will be randomly choosen from the given interval.
   // value - duration is fixed.
  ('[' _from=INT ',' to=INT ']') | value = INT
;

    */

WORD:
    INT|/[-\w]*\b/
;


Point:
  '[' x=INT ',' y=INT ']'
;

Block:
  Sequence | Randomize
;

TestInstance:
  'test' type=[TestType] runs=INT
    (practice?="practice" (randomize?="randomize" randomize_all?="all")?)#
;

ScreenInstance:
  'screen' type=[ScreenType]
;

Reference:
  TestInstance | ScreenInstance
;

StructureElement:
  Reference | Block
;


Structure:
  'structure' '{'
    elements*=StructureElement
  '}'
;

Sequence:
  'sequence' '{'
    elements*=StructureElement
  '}'
;

Randomize:
  'randomize' '{'
    elements*=StructureElement
  '}'
;

ScreenType:
  'screen' name=ID "{"
  /*    content=/(.|\n)*?(?=})/  */
      content=/[^}]*/
  '}'
;

Target:
  'target' name=ID '{'
    'output' '=' output=STRING
    'responses' '{'
        responseMap*=ResponseMap
    '}'
    targetParam*=TargetParam
  '}'
;

TargetParam:
  name=ID '=' value=BASETYPE
;

ResponseMap:
  name=ID '=' target=BASETYPE
;

// Special rule for comments
Comment:
  /\/\/.*$/|/\/\*(.|\n)*?\*\//  // Non-greedy match of block component content
;


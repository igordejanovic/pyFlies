{# vim: filetype=django tabstop=4 shiftwidth=4 expandtab
-#}
{#
Routine can be of screen or test type. If screen there is only one
textual stimulus that need to be shown to the user.
If routine is of test type than we have arbitrary number of components.
-#}
{% macro init_component(comp) %}
{{comp|comp_type}}(win=win, name='{{comp.name}}',{% if comp.type.name == 'cross' %} vertices='cross',{% endif %}

  {% for param in comp.params %}
    {% if param|param_used %}
      {{param|param_name}} = {{param|param_value}}{% if not loop.last %},{% endif %}

    {% endif %}
  {% endfor %})
{% endmacro %}

{% macro init_routine_components(routine) -%}
# Initialize components for Routine "{{routine.name}}"
{{routine.name}}_clock = core.Clock()
{% if routine|type == 'Screen' -%}
{{routine.name}}_screen = visual.TextStim(win=win, name='{{routine.name}}',
    text=r'''{{routine.content}}''',
    font='arial',
    pos=[0, 0], height=0.1, wrapWidth=None, ori=0,
    color=[1, 1, 1], colorSpace='rgb', opacity=1,
    languageStyle='LTR', depth=0.0)
{{routine.name}}_components = [{{routine.name}}_screen]
{% else %}
  {% for component in routine.components -%}
{{component.name}} = {{init_component(component)}}
  {% endfor %}

{{routine.name}}_components = [
    {{routine.components|map(attribute='name')|join(',\n    ')}}]
{% endif %}

{% endmacro %}

{% macro execute_routine(routine, indent=0) %}
{% filter indent(width=indent) %}
# ------Prepare to start Routine "{{routine.name}}"-------
continueRoutine = True
# update component parameters for each repeat
ready.keys = []
ready.rt = []
_ready_allKeys = []
# keep track of which components have finished
for thisComponent in {{routine.name}}_components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
instructClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# ----- Run Routine "{{routine.name}}" --------
while continueRoutine:
    # get current time
    t = {{routine.name}}Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock={{routine.name}}Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame

  {% for component in routine.components %}
  {% endfor %}
{% endfilter %}
{% endmacro %}

{%- macro execute_block(block, indent=0) -%}
  {% for statement in block.statements -%}
    {% if statement|type == 'Repeat' %}

    {% else %}
      {{execute_routine(statement.screen, indent)}}
    {% endif %}
  {%- endfor %}
{%- endmacro %}

{% for routine in m.routines %}
{% endfor %}

#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
{{m.description}}
----

WARNING:
This test was generated by pyFlies (https://github.com/igordejanovic/pyFlies)
on {{now}} based on the PsychoPy Builder compiler code.

If you are going to regenerate this file from the pyFlies model again
do not edit it manually or else your manual changes will be lost.
"""

from __future__ import absolute_import, division

from psychopy import locale_setup
from psychopy import prefs
from psychopy import gui, visual, core, data, event, logging, clock
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER)
from psychopy.sound import backend_ptb as sound

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle
import os  # handy system and path functions
import sys  # to get file system encoding

from psychopy.hardware import keyboard


# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
os.chdir(_thisDir)

# Store info about the experiment session
psychopyVersion = '2020.2.0'
expName = '{{expName}}'  # from the Builder filename that created this script
expInfo = {'participant': '', 'session': '001'}
dlg = gui.DlgFromDict(dictionary=expInfo, sort_keys=False, title=expName)
if dlg.OK == False:
    core.quit()  # user pressed cancel
expInfo['date'] = data.getDateStr()  # add a simple timestamp
expInfo['expName'] = expName
expInfo['psychopyVersion'] = psychopyVersion

# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
filename = _thisDir + os.sep + u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])

# An ExperimentHandler isn't essential but helps with data saving
thisExp = data.ExperimentHandler(name=expName, version='',
    extraInfo=expInfo, runtimeInfo=None,
    originPath='/home/igor/repos/pyFlies/src/generators/textx-gen-pyflies-psychopy/builder-gen-proba/proba.py',
    savePickle=True, saveWideText=True,
    dataFileName=filename)
# save a log file for detail verbose info
logFile = logging.LogFile(filename+'.log', level=logging.EXP)
logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file

endExpNow = False  # flag for 'escape' or other condition => quit the exp
frameTolerance = 0.001  # how close to onset before 'same' frame

# Start Code - component code to be run before the window creation

# Setup the Window
win = visual.Window(
    size={{settings.resolution}}, fullscr=True, screen=0,
    winType='pyglet', allowGUI=False, allowStencil=False,
    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',
    blendMode='avg', useFBO=True,
    units='height')
# store frame rate of monitor if we can measure it
expInfo['frameRate'] = win.getActualFrameRate()
if expInfo['frameRate'] != None:
    frameDur = 1.0 / round(expInfo['frameRate'])
else:
    frameDur = 1.0 / 60.0  # could not measure, so guess

# create a default keyboard (e.g. to check for escape)
defaultKeyboard = keyboard.Keyboard()

{# Components initialization #}
{% for routine in m.routines -%}
{{init_routine_components(routine)}}
{%- endfor %}

{# Trial data #}
{% for routine in m.routines -%}
  {% if routine|type == 'Test' %}
# Trial component settings for {{routine.name}} test
{{routine.name}}_trials = [
    {% for trial in routine.table %}
      # Trial {{loop.index}}
      {
      {% if trial.ph_fix %}
        'ph_fix': [{{trial.ph_fix|map(attribute='component')|map(attribute='name')|join(', ')}}]
      {% endif %}
      {% if trial.ph_exec %}
        'ph_exec': [{{trial.ph_exec|map(attribute='component')|map(attribute='name')|join(', ')}}],
      {% endif %}
      {% if trial.ph_error %}
        'ph_error': [{{trial.ph_error|map(attribute='component')|map(attribute='name')|join(', ')}}],
      {% endif %}
      {% if trial.ph_correct %}
        'ph_correct': [{{trial.ph_correct(attribute='component')|map(attribute='name')|join(', ')}}],
      {% endif %}
      {% for comp_time in trial.comp_times %}
        '{{comp_time.component.name}}': {'at': {{comp_time.at}}, 'duration': {{comp_time.duration}},
        {%- for param in comp_time.component.params %}
          {% if not param.is_constant -%}
          '{{param|param_name}}': {{param|param_value}},
          {%- endif %}
        {% endfor -%}
        },
      {% endfor %}
      },
    {% endfor %}
]
  {% endif %}
{% endfor %}

# Create some handy timers
globalClock = core.Clock()  # to track the time since experiment started
routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine

{# Execute flow #}
{{execute_block(m.flow)}}

# Flip one final time so any remaining win.callOnFlip()
# and win.timeOnFlip() tasks get executed before quitting
win.flip()

# these shouldn't be strictly necessary (should auto-save)
thisExp.saveAsWideText(filename+'.csv', delim='auto')
thisExp.saveAsPickle(filename)
logging.flush()
# make sure everything is closed down
thisExp.abort()  # or data files will save again on exit
win.close()
core.quit()

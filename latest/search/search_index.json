{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyFlies A Domain-Specific Language (DSL) for experiments specification in cognitive sciences pyFlies is a Domain-Specific Language (DSL) for cognitive experiments modeling. It is meant to be highly readable and simple to learn. The aim of the language is to capture the essence of the experiment and to leave the details to the compiler. A code for various run-time platforms can be generated from the experiment description. Currently PsychoPy is fully supported and we plan to build generators for other targets. Features: High-level. Easy to write and read. Experiments can be defined in minutes! From experiment description a source code for various platforms can be automatically generated. Declarative language. Specify what needs to be done and leave how part to the pyFlies. Integrates in VS Code . One of the most popular code editors today. Written in Python programming language. Easy to extend. Generators are plugins which can be developed independently. Fully free and open source. GPL license. Hosted on github . Easy to contribute to. Getting started Installation Install Python and check that it is available on the command line by running: python --version It is recommended to use Python virtual environments to isolate different set of Python libraries. Create virtual environment for pyFlies by running: python -m venv pyflies-venv This will create folder pyflies-venv where your libraries will be installed. You need to activate virtual environment before usage: source pyflies-venv/bin/activate (for Linux and other POSIX systems) pyflies-env\\Scripts\\activate.bat (for Windows) Now, you can install pyFlies and generator for PsychoPy with: pip install pyflies-psychopy To verify that pyFlies is installed you can run: textx list-generators You can see in the output that the generator pyFlies -> PsychoPy is available. pyFlies specifications are pure text and can be edited by any textual editor but for a good experience (especially with tables) it is recommended that VS Code and pyFlies extension is used. Install VS Code either for you OS package manager or by going to VS Code download page and downloading package for your operating system. In the list of extensions find pyFlies and click on install . Note You can watch the process of installation in this video . In the video we are using Linux but most of the information is valid for other OSes. Video tutorials The best way to start with pyFlies is by watching some of our video tutorials. Try examples Clone or download pyFlies repo. Unpack and load examples from examples folder in the editor or pyFlies GUI. Update experiment definition to your taste. Generate and run experiment. Discuss, ask questions For all questions, feature requires and bug report please use the GitHub issue tracker Screenshots (click for a popup) Editing specification Experiment is created and modified in a convenient to use editor. Generated log From an experiment specification a full log of the experiment flow is generated which can be used to investigate and debug the experiment. Generated PsychoPy code From an experiment specification Python code for PsychoPy is generated which is used to run the experiment. Credits pyFlies icon is based on an icon licensed by CC BY 3.0 from Icon Fonts .","title":"Home"},{"location":"#pyflies","text":"A Domain-Specific Language (DSL) for experiments specification in cognitive sciences pyFlies is a Domain-Specific Language (DSL) for cognitive experiments modeling. It is meant to be highly readable and simple to learn. The aim of the language is to capture the essence of the experiment and to leave the details to the compiler. A code for various run-time platforms can be generated from the experiment description. Currently PsychoPy is fully supported and we plan to build generators for other targets. Features: High-level. Easy to write and read. Experiments can be defined in minutes! From experiment description a source code for various platforms can be automatically generated. Declarative language. Specify what needs to be done and leave how part to the pyFlies. Integrates in VS Code . One of the most popular code editors today. Written in Python programming language. Easy to extend. Generators are plugins which can be developed independently. Fully free and open source. GPL license. Hosted on github . Easy to contribute to.","title":"pyFlies"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#installation","text":"Install Python and check that it is available on the command line by running: python --version It is recommended to use Python virtual environments to isolate different set of Python libraries. Create virtual environment for pyFlies by running: python -m venv pyflies-venv This will create folder pyflies-venv where your libraries will be installed. You need to activate virtual environment before usage: source pyflies-venv/bin/activate (for Linux and other POSIX systems) pyflies-env\\Scripts\\activate.bat (for Windows) Now, you can install pyFlies and generator for PsychoPy with: pip install pyflies-psychopy To verify that pyFlies is installed you can run: textx list-generators You can see in the output that the generator pyFlies -> PsychoPy is available. pyFlies specifications are pure text and can be edited by any textual editor but for a good experience (especially with tables) it is recommended that VS Code and pyFlies extension is used. Install VS Code either for you OS package manager or by going to VS Code download page and downloading package for your operating system. In the list of extensions find pyFlies and click on install . Note You can watch the process of installation in this video . In the video we are using Linux but most of the information is valid for other OSes.","title":"Installation"},{"location":"#video-tutorials","text":"The best way to start with pyFlies is by watching some of our video tutorials.","title":"Video tutorials"},{"location":"#try-examples","text":"Clone or download pyFlies repo. Unpack and load examples from examples folder in the editor or pyFlies GUI. Update experiment definition to your taste. Generate and run experiment.","title":"Try examples"},{"location":"#discuss-ask-questions","text":"For all questions, feature requires and bug report please use the GitHub issue tracker","title":"Discuss, ask questions"},{"location":"#screenshots-click-for-a-popup","text":"","title":"Screenshots (click for a popup)"},{"location":"#editing-specification","text":"Experiment is created and modified in a convenient to use editor.","title":"Editing specification"},{"location":"#generated-log","text":"From an experiment specification a full log of the experiment flow is generated which can be used to investigate and debug the experiment.","title":"Generated log"},{"location":"#generated-psychopy-code","text":"From an experiment specification Python code for PsychoPy is generated which is used to run the experiment.","title":"Generated PsychoPy code"},{"location":"#credits","text":"pyFlies icon is based on an icon licensed by CC BY 3.0 from Icon Fonts .","title":"Credits"},{"location":"components/","text":"Component definitions Components are internally defined using DSL for component specification. Currently this DSL is not exposed to end users but we have plan to do so in the future to support specification of additional components that are not provided by pyFlies. We must assert that making non-standard components will make experiment specification non-portable across different target generators but it could be invaluable in the situations where non-standard components are required and portability is not an issue. This page is generated on 2020-10-28 19:33:00 from component descriptions during build so what is documented here is what pyFlies actually uses: base // Base abstract components that define common properties abstract component visual \"\"\" The definition of parameters used by all visual stimuli \"\"\" { param position:point = (0, 0) \"\"\" The position of the component. By default center of the screen. \"\"\" param size:[symbol, int] = 20 \"\"\" The size of the component. May be given in descriptive way or as a size in the coordinate space. \"\"\" param color:[symbol, color] = #ffffff \"\"\" This color is used for border of the component. Default is white. \"\"\" param fillColor:[symbol, color] = #ffffff \"\"\" This color is used to fill the interior of the visual component. Default is white. \"\"\" } abstract component audible \"\"\" This is an abstract component that should be inherited by all components that play sounds. \"\"\" {} abstract component input \"\"\" This is an abstract component that should be inherited by all components that accepts input from the subject. \"\"\" {} cross component cross extends visual \"\"\" Usually used as a fixation point \"\"\" {} circle component circle extends visual \"\"\" Visual stimuli in the shape of a circle. \"\"\" { param radius:int = 20 \"\"\" The radius of the circle. \"\"\" } text component text extends visual \"\"\" A component for displaying text \"\"\" { param content: string = 'default text' \"\"\" A mandatory content for display \"\"\" } line component line extends visual \"\"\" Visual stimuli representing line between two points \"\"\" { param from:[symbol, point] = (-50, 0) \"\"\" The start point of the line shape \"\"\" param to:[symbol, point] = (50, 0) \"\"\" The end point of the line shape \"\"\" } rectangle component rectangle extends visual \"\"\" Visual stimuli in the form of rectangle \"\"\" { // override size to be of point type // 0 for height means 'keep aspect ratio' param size:[symbol, point] = (20, 20) } image component image extends visual \"\"\" A component that displays image loaded from file \"\"\" { param file: string = 'default path' \"\"\" A file path relative to the model file. \"\"\" param ori: int = 0 \"\"\" Orijentation in degrees. \"\"\" } audio component audio extends audible \"\"\" Plays audio loaded from the given file \"\"\" { param file: string = 'default path' \"\"\" The file to load audio from \"\"\" } sound component sound extends audible \"\"\" Plays sound of the given frequency \"\"\" { param freq: int = 500 \"\"\" The frequency of the sound \"\"\" } keyboard component keyboard extends input \"\"\" Component for implementing keyboard input \"\"\" { param valid:[symbol, list] = space \"\"\" What is considered a valid keystroke in the trial. Can be a list of valid keys. \"\"\" param correct:[symbol, list] = space \"\"\" What is a correct response for this trial. Can be a single key or a list of keys. If this parameter is provided, must be found in valid list of keys. If not given any key from the list of valid keys is considered correct. \"\"\" } mouse component mouse extends input \"\"\" Component for implementing mouse input \"\"\" { param target:[symbol, list] = none \"\"\" A component name or a list of component names which represents valid targets. If target is none than any click is valid. \"\"\" }","title":"Components"},{"location":"components/#component-definitions","text":"Components are internally defined using DSL for component specification. Currently this DSL is not exposed to end users but we have plan to do so in the future to support specification of additional components that are not provided by pyFlies. We must assert that making non-standard components will make experiment specification non-portable across different target generators but it could be invaluable in the situations where non-standard components are required and portability is not an issue. This page is generated on 2020-10-28 19:33:00 from component descriptions during build so what is documented here is what pyFlies actually uses:","title":"Component definitions"},{"location":"components/#base","text":"// Base abstract components that define common properties abstract component visual \"\"\" The definition of parameters used by all visual stimuli \"\"\" { param position:point = (0, 0) \"\"\" The position of the component. By default center of the screen. \"\"\" param size:[symbol, int] = 20 \"\"\" The size of the component. May be given in descriptive way or as a size in the coordinate space. \"\"\" param color:[symbol, color] = #ffffff \"\"\" This color is used for border of the component. Default is white. \"\"\" param fillColor:[symbol, color] = #ffffff \"\"\" This color is used to fill the interior of the visual component. Default is white. \"\"\" } abstract component audible \"\"\" This is an abstract component that should be inherited by all components that play sounds. \"\"\" {} abstract component input \"\"\" This is an abstract component that should be inherited by all components that accepts input from the subject. \"\"\" {}","title":"base"},{"location":"components/#cross","text":"component cross extends visual \"\"\" Usually used as a fixation point \"\"\" {}","title":"cross"},{"location":"components/#circle","text":"component circle extends visual \"\"\" Visual stimuli in the shape of a circle. \"\"\" { param radius:int = 20 \"\"\" The radius of the circle. \"\"\" }","title":"circle"},{"location":"components/#text","text":"component text extends visual \"\"\" A component for displaying text \"\"\" { param content: string = 'default text' \"\"\" A mandatory content for display \"\"\" }","title":"text"},{"location":"components/#line","text":"component line extends visual \"\"\" Visual stimuli representing line between two points \"\"\" { param from:[symbol, point] = (-50, 0) \"\"\" The start point of the line shape \"\"\" param to:[symbol, point] = (50, 0) \"\"\" The end point of the line shape \"\"\" }","title":"line"},{"location":"components/#rectangle","text":"component rectangle extends visual \"\"\" Visual stimuli in the form of rectangle \"\"\" { // override size to be of point type // 0 for height means 'keep aspect ratio' param size:[symbol, point] = (20, 20) }","title":"rectangle"},{"location":"components/#image","text":"component image extends visual \"\"\" A component that displays image loaded from file \"\"\" { param file: string = 'default path' \"\"\" A file path relative to the model file. \"\"\" param ori: int = 0 \"\"\" Orijentation in degrees. \"\"\" }","title":"image"},{"location":"components/#audio","text":"component audio extends audible \"\"\" Plays audio loaded from the given file \"\"\" { param file: string = 'default path' \"\"\" The file to load audio from \"\"\" }","title":"audio"},{"location":"components/#sound","text":"component sound extends audible \"\"\" Plays sound of the given frequency \"\"\" { param freq: int = 500 \"\"\" The frequency of the sound \"\"\" }","title":"sound"},{"location":"components/#keyboard","text":"component keyboard extends input \"\"\" Component for implementing keyboard input \"\"\" { param valid:[symbol, list] = space \"\"\" What is considered a valid keystroke in the trial. Can be a list of valid keys. \"\"\" param correct:[symbol, list] = space \"\"\" What is a correct response for this trial. Can be a single key or a list of keys. If this parameter is provided, must be found in valid list of keys. If not given any key from the list of valid keys is considered correct. \"\"\" }","title":"keyboard"},{"location":"components/#mouse","text":"component mouse extends input \"\"\" Component for implementing mouse input \"\"\" { param target:[symbol, list] = none \"\"\" A component name or a list of component names which represents valid targets. If target is none than any click is valid. \"\"\" }","title":"mouse"},{"location":"condition-tables/","text":"Condition tables Condition tables define one or more variables in each column and their values in each row. They are used to specify values of related variables given in a row representing a certain state. These tables are used in test defintion and for repeat with form of repetition. In the test definition each row of the table represent a single test trial. While in repeat with statement each row represent a single cycle through the repeat loop where the values of the variables will be from the corresponding table row. | number | parity | |--------------|----------| | numbers loop | parities | The header of the table contains variable names while the cells of the rest of the table contain expressions . Tables are usually, although not necessary, written in a compact form which is expanded during compilation. This compact representation is shorted, require less screen space and gives more flexibility in adding new variables. Note Tables are written in pure text and can be edited with any editor but for a convenience pyFlies VS Code editor has auto-formatting and navigation capabilities which makes editing much more pleasant. To understand table expansion lets look at some examples. Lets say we want to loop through several color and for each color to loop through some direction to explore all possible variations. We can do that in the following way: | color | direction | | ----------------------- | ------------------ | | [red, green, blue] loop | [left, right] loop | The expression in both columns are loop expression over list of symbols. Loop expression are evaluated and nested from left to right, so the table in expanded form will be: | color | direction | | ----- | --------- | | red | left | | red | right | | green | left | | green | right | | blue | left | | blue | right | Tip Use log generator to produce expanded tables, and other interesting information about your experiment. Now, lets expand the table a bit. Lets suppose that we want a new table variable called congruency that has value congruent if color is green and incongruent otherwise. For this we can use if expression: | color | direction | congruency | | ----------------------- | ------------------ | -------------------------------------------- | | [red, green, blue] loop | [left, right] loop | congruent if color == green else incongruent | See how we referenced color variable in the congruency column and compare its value with the symbol green . now the expanded table will be: | color | direction | congruency | | ----- | --------- | ----------- | | red | left | incongruent | | red | right | incongruent | | green | left | congruent | | green | right | congruent | | blue | left | incongruent | | blue | right | incongruent | Tip To make table expressions simpler you can always define variables which can hold a used sequence or a whole expression. For example: colors = [red, green, blue] directions = [left, right] is_congruent = congruent if color == green else incongruent test MyTest { | index | color | direction | congruency | | ----- | ----------- | --------------- | ------------ | | 1..8 | colors loop | directions loop | is_congruent | } Now, lets say we want to introduce index variable which will be the number of the current row. In compact form it is easy: | index | color | direction | congruency | | ----- | ----------------------- | ------------------ | -------------------------------------------- | | 1..8 | [red, green, blue] loop | [left, right] loop | congruent if color == green else incongruent | Notice the use of the range type as the expression in the index column. If we have a sequence-like type (list or range) then the value will cycle, i.e. for each row the next value from the sequence will be used until the sequence is exhausted. After that the sequence will start from the beginning. So, we can say that loop expression take precedence. If the row has loop expressions they will be used, from left to right, to drive the row creation and the sequences will be fillers. If no loop exists in the row, sequences will expand until the longest is exhausted. Consider this example: | color | direction | | ------------------ | ------------- | | [red, green, blue] | [left, right] | Since we have no loops the table will expand to three rows, until the colors are exhausted while the direction will cycle: | color | direction | | ----- | --------- | | red | left | | green | right | | blue | left | In the previous example where we added index column with range 1..8 , we could easily specify larger range 1..100 and the result will be the same. That is because we have loops in the column and the index is just the filler so that after row 8 is created all loops are over and the expansion stops. We can specify multiple rows even in a compact form, and can mix and match constant rows with expression based. For example: | index | color | direction | | ------ | ----------------------- | ------------------ | | 1..2 | [orange, brown] | up | | 3..100 | [red, green, blue] loop | [left, right] loop | will expand to: | index | color | direction | |-------|--------|-----------| | 1 | orange | up | | 2 | brown | up | | 3 | red | left | | 4 | red | right | | 5 | green | left | | 6 | green | right | | 7 | blue | left | So, the first row will expand and then the second. Now, you can see that creating table of condition is easy and very powerful. Tip pyFlies provides CSV generator, which is a standard textX based generator like all others, that you can use to create condition table using pyFlies powerful syntax and table expansion and export it for use in other tools.","title":"Condition tables"},{"location":"condition-tables/#condition-tables","text":"Condition tables define one or more variables in each column and their values in each row. They are used to specify values of related variables given in a row representing a certain state. These tables are used in test defintion and for repeat with form of repetition. In the test definition each row of the table represent a single test trial. While in repeat with statement each row represent a single cycle through the repeat loop where the values of the variables will be from the corresponding table row. | number | parity | |--------------|----------| | numbers loop | parities | The header of the table contains variable names while the cells of the rest of the table contain expressions . Tables are usually, although not necessary, written in a compact form which is expanded during compilation. This compact representation is shorted, require less screen space and gives more flexibility in adding new variables. Note Tables are written in pure text and can be edited with any editor but for a convenience pyFlies VS Code editor has auto-formatting and navigation capabilities which makes editing much more pleasant. To understand table expansion lets look at some examples. Lets say we want to loop through several color and for each color to loop through some direction to explore all possible variations. We can do that in the following way: | color | direction | | ----------------------- | ------------------ | | [red, green, blue] loop | [left, right] loop | The expression in both columns are loop expression over list of symbols. Loop expression are evaluated and nested from left to right, so the table in expanded form will be: | color | direction | | ----- | --------- | | red | left | | red | right | | green | left | | green | right | | blue | left | | blue | right | Tip Use log generator to produce expanded tables, and other interesting information about your experiment. Now, lets expand the table a bit. Lets suppose that we want a new table variable called congruency that has value congruent if color is green and incongruent otherwise. For this we can use if expression: | color | direction | congruency | | ----------------------- | ------------------ | -------------------------------------------- | | [red, green, blue] loop | [left, right] loop | congruent if color == green else incongruent | See how we referenced color variable in the congruency column and compare its value with the symbol green . now the expanded table will be: | color | direction | congruency | | ----- | --------- | ----------- | | red | left | incongruent | | red | right | incongruent | | green | left | congruent | | green | right | congruent | | blue | left | incongruent | | blue | right | incongruent | Tip To make table expressions simpler you can always define variables which can hold a used sequence or a whole expression. For example: colors = [red, green, blue] directions = [left, right] is_congruent = congruent if color == green else incongruent test MyTest { | index | color | direction | congruency | | ----- | ----------- | --------------- | ------------ | | 1..8 | colors loop | directions loop | is_congruent | } Now, lets say we want to introduce index variable which will be the number of the current row. In compact form it is easy: | index | color | direction | congruency | | ----- | ----------------------- | ------------------ | -------------------------------------------- | | 1..8 | [red, green, blue] loop | [left, right] loop | congruent if color == green else incongruent | Notice the use of the range type as the expression in the index column. If we have a sequence-like type (list or range) then the value will cycle, i.e. for each row the next value from the sequence will be used until the sequence is exhausted. After that the sequence will start from the beginning. So, we can say that loop expression take precedence. If the row has loop expressions they will be used, from left to right, to drive the row creation and the sequences will be fillers. If no loop exists in the row, sequences will expand until the longest is exhausted. Consider this example: | color | direction | | ------------------ | ------------- | | [red, green, blue] | [left, right] | Since we have no loops the table will expand to three rows, until the colors are exhausted while the direction will cycle: | color | direction | | ----- | --------- | | red | left | | green | right | | blue | left | In the previous example where we added index column with range 1..8 , we could easily specify larger range 1..100 and the result will be the same. That is because we have loops in the column and the index is just the filler so that after row 8 is created all loops are over and the expansion stops. We can specify multiple rows even in a compact form, and can mix and match constant rows with expression based. For example: | index | color | direction | | ------ | ----------------------- | ------------------ | | 1..2 | [orange, brown] | up | | 3..100 | [red, green, blue] loop | [left, right] loop | will expand to: | index | color | direction | |-------|--------|-----------| | 1 | orange | up | | 2 | brown | up | | 3 | red | left | | 4 | red | right | | 5 | green | left | | 6 | green | right | | 7 | blue | left | So, the first row will expand and then the second. Now, you can see that creating table of condition is easy and very powerful. Tip pyFlies provides CSV generator, which is a standard textX based generator like all others, that you can use to create condition table using pyFlies powerful syntax and table expansion and export it for use in other tools.","title":"Condition tables"},{"location":"test/","text":"Test definition A test represents the main concept in pyFlies language. Each test has a name, a condition table defining variables and their values for each trial, and component specifications with mapping to trials. On this page we will use an example to show how tests are defined and we will provide references to other pages describing each segment of the definition in more details. Here is an example of a test: The example represents the definition of the Eriksen Flanker task published in: Eriksen, B. A.; Eriksen, C. W. (1974). \"Effects of noise letters upon identification of a target letter in a non- search task\". Perception and Psychophysics. 16: 143\u2013149. The target is flanked by non-target stimuli which correspond either to the same directional response as the target (congruent flankers), to the opposite response (incongruent flankers). In this example we are using arrows which points to the left or to the right. The surrounding non-target stimuli will be congruent (points to the same direction), or incongruent (points to the opposite direction). Before the test we have three variables defined which we shall use in the test: directions - a list of directions, congruencies - a list of congruencies as each trial can be either congruent or inconguruent, and repeats - a number of repeats we shall use to change the total number of trials during the test run. There are three variables defined in the header of the table of conditions: repeat - used to control total number of trials per test run, direction - contains the direction of the target stimuli, category - holds information if the current trial is congruent or not. Table expansion Values of each trial variable is given as an expression in the table first non-header row. You can see that each expression is a loop expression which will loop over the given sequence to expand the table. Loops are evaluated from left to right, leftmost loop being the top-level outer loop while the rightmost loop being the inner loop. We could also have a sequence without the loop in which case the sequence would cycle, or any other expression involving global and trail variables and literal values. For repeats value of 1 , as defined globally, this table expands as follow: We could as well write condition table in the expanded style but it would be less flexible as it would be harder to add new variables, to use repetition for total number of trials etc. For the details of condition table specification see Condition Tables section. Tip Although, pyFlies specifications are just plain textual files and can be edited in any text editor, it is much more convenient to edit tables in editor that supports them, like provided VS Code pyFlies extension . The second part of the test definition are mappings of components to trials. These mappings define the components (stimuli and inputs), their timings and conditions under which they should be shown to the user. These mappings are given in the form: <condition> -> <list of components with timings> where left-hand side (LHS) <condition> is boolean expression which when evaluated to true in the context of the current trial means that the components on the right side are used in the trial. Trial phases For better organization, each trial execution is separated in the three phases: fix , exec and error/correct . The phases are executed in succession and for each execution builtin boolean variables fix , exec , error , correct get value of true for corresponding phase, thus those variables can be used in LHS expressions to match the phase. In the above example we have fix -> cross.. . LHS condition is just fix variable which will be true during fix phase of each trial. Thus, cross component will be shown to the user during each fix phase. If we wanted, for example, to show cross only for odd trials we could write: fix and parity == odd -> cross() for 1000 Notice the part of the definition for 1000 . Each component can optionally define its duration in miliseconds. Here we specify that the cross component will be shown for 1s. If duration is not provided it means indefinitely and the component will last until the end of the phase. We usually use indefinite durations when we have input components which terminate phases on user input. Tip Expressions are used almost everywhere and they can range from just a simple literal value to a more complex expressions using local and global variables. In the exec phase we have two components image and keyboard . First component will display the given image, and the second will wait for the user input. The image component has file defined as variable string created by interpolating direction and category values from the current trial. All strings support powerful templating provided by the Jinja template engine . keyboard component has two parameters: valid - a list of valid keys, and correct - what is considered a correct response. Notice that we have defined valid keys and correct response in abstract terms representing directions. pyFlies tries to capture the essence of the test and thus parameters and variables are defined in abstract terms. The detailed mapping is provided by the code generator and the default mappings can be overriden by the target configuration At the end we specify what will happen in correct and error phases of the trial. We choose to show green or red circle but we could also choose to play sounds, or we could leave these phases out if we don't want it. Remember that correct and error are just boolean variables that are true during phase calculation. Each trial must have components defined for at least exec phase (i.e. evaluation for exec == true must yield components to show). If that is not satisfied the error will be reported during compilation.","title":"Test definition"},{"location":"test/#test-definition","text":"A test represents the main concept in pyFlies language. Each test has a name, a condition table defining variables and their values for each trial, and component specifications with mapping to trials. On this page we will use an example to show how tests are defined and we will provide references to other pages describing each segment of the definition in more details. Here is an example of a test: The example represents the definition of the Eriksen Flanker task published in: Eriksen, B. A.; Eriksen, C. W. (1974). \"Effects of noise letters upon identification of a target letter in a non- search task\". Perception and Psychophysics. 16: 143\u2013149. The target is flanked by non-target stimuli which correspond either to the same directional response as the target (congruent flankers), to the opposite response (incongruent flankers). In this example we are using arrows which points to the left or to the right. The surrounding non-target stimuli will be congruent (points to the same direction), or incongruent (points to the opposite direction). Before the test we have three variables defined which we shall use in the test: directions - a list of directions, congruencies - a list of congruencies as each trial can be either congruent or inconguruent, and repeats - a number of repeats we shall use to change the total number of trials during the test run. There are three variables defined in the header of the table of conditions: repeat - used to control total number of trials per test run, direction - contains the direction of the target stimuli, category - holds information if the current trial is congruent or not.","title":"Test definition"},{"location":"test/#table-expansion","text":"Values of each trial variable is given as an expression in the table first non-header row. You can see that each expression is a loop expression which will loop over the given sequence to expand the table. Loops are evaluated from left to right, leftmost loop being the top-level outer loop while the rightmost loop being the inner loop. We could also have a sequence without the loop in which case the sequence would cycle, or any other expression involving global and trail variables and literal values. For repeats value of 1 , as defined globally, this table expands as follow: We could as well write condition table in the expanded style but it would be less flexible as it would be harder to add new variables, to use repetition for total number of trials etc. For the details of condition table specification see Condition Tables section. Tip Although, pyFlies specifications are just plain textual files and can be edited in any text editor, it is much more convenient to edit tables in editor that supports them, like provided VS Code pyFlies extension . The second part of the test definition are mappings of components to trials. These mappings define the components (stimuli and inputs), their timings and conditions under which they should be shown to the user. These mappings are given in the form: <condition> -> <list of components with timings> where left-hand side (LHS) <condition> is boolean expression which when evaluated to true in the context of the current trial means that the components on the right side are used in the trial.","title":"Table expansion"},{"location":"test/#trial-phases","text":"For better organization, each trial execution is separated in the three phases: fix , exec and error/correct . The phases are executed in succession and for each execution builtin boolean variables fix , exec , error , correct get value of true for corresponding phase, thus those variables can be used in LHS expressions to match the phase. In the above example we have fix -> cross.. . LHS condition is just fix variable which will be true during fix phase of each trial. Thus, cross component will be shown to the user during each fix phase. If we wanted, for example, to show cross only for odd trials we could write: fix and parity == odd -> cross() for 1000 Notice the part of the definition for 1000 . Each component can optionally define its duration in miliseconds. Here we specify that the cross component will be shown for 1s. If duration is not provided it means indefinitely and the component will last until the end of the phase. We usually use indefinite durations when we have input components which terminate phases on user input. Tip Expressions are used almost everywhere and they can range from just a simple literal value to a more complex expressions using local and global variables. In the exec phase we have two components image and keyboard . First component will display the given image, and the second will wait for the user input. The image component has file defined as variable string created by interpolating direction and category values from the current trial. All strings support powerful templating provided by the Jinja template engine . keyboard component has two parameters: valid - a list of valid keys, and correct - what is considered a correct response. Notice that we have defined valid keys and correct response in abstract terms representing directions. pyFlies tries to capture the essence of the test and thus parameters and variables are defined in abstract terms. The detailed mapping is provided by the code generator and the default mappings can be overriden by the target configuration At the end we specify what will happen in correct and error phases of the trial. We choose to show green or red circle but we could also choose to play sounds, or we could leave these phases out if we don't want it. Remember that correct and error are just boolean variables that are true during phase calculation. Each trial must have components defined for at least exec phase (i.e. evaluation for exec == true must yield components to show). If that is not satisfied the error will be reported during compilation.","title":"Trial phases"},{"location":"about/contributing/","text":"pyFlies is open for contributions. You can contribute code, documentation, tests, bug reports. If you plan to make a contribution it would be great if you first announce that on the discussion forum. For bug reports please use github issue tracker . For code/doc/test contributions do the following: Fork the project on github . Clone your fork. Make a branch for the new feature and switch to it. Make one or more commits. Push your branch to github. Make a pull request. I will look at the changes and if everything is ok I will pull it in. Note For code contributions please try to adhere to the PEP-8 guidelines . Although I am not strict in that regard it is useful to have a common ground for coding style. To make things easier use tools for code checking (PyLint, PyFlakes, pep8 etc.).","title":"Contributing"},{"location":"about/license/","text":"Copyright (c) Igor Dejanovi\u0107 This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/ .","title":"License"},{"location":"about/release_notes/","text":"","title":"Release Notes"}]}